import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha4;

const X_RES = 800;
const Y_RES = 600;

const UNIT_RADIUS = 10.0;
const UNIT_SPEED = 1.5;

const PROGRESS_THRESHOLD = 0.25;

const CELL_SIZE = 30.0;

class Unit {
	field pos;
	field angle = Random.randomFloat() * 2 * Math.PI;
	field targetPos;
	field lastPos;
	field color;

	constructor(pos) {
		this.pos = pos;
	}
}

class Necromage : Unit {
	field zombies = [];

	constructor(pos) : base(pos) {
		this.color = [0, 192, 255];
	}
}

class Zombie : Unit {
	constructor(pos) : base(pos) {
		this.color = [64, 128, 0];
	}
}

class Peasant : Unit {
	constructor(pos) : base(pos) {
		this.color = [128, 96, 64];
	}
}

class MainScene : AbstractScene {
	field cameraPos;
	field mouseDown = false;

	field units = [];
	field necromage;

	constructor() {
		this.necromage = new Necromage([0, 0]);
		this.cameraPos = this.necromage.pos;
		this.units.add(this.necromage);

		for (i = 0; i < 50; ++i) {
			zombie = new Zombie([100, 0]);
			this.units.add(zombie);
			this.necromage.zombies.add(zombie);
		}
		for (i = 0; i < 50; ++i) {
			this.units.add(new Peasant([-100, 0]));
		}
	}

	function screenToGame(pos) {
		return
			[ pos[0] + this.cameraPos[0] - X_RES / 2
			, pos[1] + this.cameraPos[1] - Y_RES / 2
			];
	}
	function gameToScreen(pos) {
		return
			[ pos[0] - this.cameraPos[0] + X_RES / 2
			, pos[1] - this.cameraPos[1] + Y_RES / 2
			];
	}

	static function d(pos1, pos2) {
		return ((pos1[0] - pos2[0]) ** 2.0 + (pos1[1] - pos2[1]) ** 2.0) ** 0.5;
	}
	static function d2(pos1, pos2) {
		return (pos1[0] - pos2[0]) ** 2.0 + (pos1[1] - pos2[1]) ** 2.0;
	}
	static function len(pos) {
		return (pos[0] ** 2.0 + pos[1] ** 2.0) ** 0.5;
	}
	static function len2(pos) {
		return pos[0] ** 2.0 + pos[1] ** 2.0;
	}
	static function vecTo(pos, target) {
		return [target[0] - pos[0], target[1] - pos[1]];
	}
	static function add(pos, vec) {
		pos[0] += vec[0];
		pos[1] += vec[1];
	}
	static function sub(pos, vec) {
		pos[0] -= vec[0];
		pos[1] -= vec[1];
	}
	static function sum(pos, vec) {
		return [pos[0] + vec[0], pos[1] + vec[1]];
	}
	static function diff(pos, vec) {
		return [pos[0] - vec[0], pos[1] - vec[1]];
	}
	static function normalize(vec, newLen = 1.0) {
		len = MainScene.len(vec);
		vec[0] *= newLen / len;
		vec[1] *= newLen / len;
	}

	function update(inputManager, events) {
		for (e : events) {
			switch (e.type) {
				case EventType.MOUSE_PRESS:
					this.mouseDown = true;
					break;
				case EventType.MOUSE_RELEASE:
					this.mouseDown = false;
					break;
				default:
					break;
			}
		}
		if (this.mouseDown) {
			this.necromage.targetPos = this.screenToGame(inputManager.getMousePosition());
		}

		// Swarm command.
		if (inputManager.isKeyPressed(KeyboardKey.SPACE)) {
			targetPos = this.screenToGame(inputManager.getMousePosition());
			for (zombie : this.necromage.zombies) {
				zombie.targetPos = targetPos.clone();
			}	
		}

		// Voluntary movement.
		for (unit : this.units) {
			if (unit.targetPos != null) {
				unit.lastPos = unit.pos.clone();
				d2 = MainScene.d2(unit.pos, unit.targetPos);
				if (d2 < UNIT_SPEED * UNIT_SPEED) {
					unit.pos = unit.targetPos;
					unit.targetPos = null;
				} else {
					vec = MainScene.vecTo(unit.pos, unit.targetPos);
					MainScene.normalize(vec, UNIT_SPEED);
					MainScene.add(unit.pos, vec);
				}
			}
		}

		// Collisions.
		for (i = 0; i < this.units.length - 1; ++i) {
			unit1 = this.units[i];
			for (j = i + 1; j < this.units.length; ++j) {
				unit2 = this.units[j];
				d2 = MainScene.d2(unit1.pos, unit2.pos);
				if (d2 == 0.0) {
					// Separate in a random direction if completely overlapping.
					theta = Random.randomFloat() * 2 * Math.PI;
					offset = [Math.cos(theta) * UNIT_RADIUS, Math.sin(theta) * UNIT_RADIUS];
					MainScene.add(unit1.pos, offset);
					MainScene.sub(unit2.pos, offset);
				} else if (d2 < (2.0 * UNIT_RADIUS) ** 2.0) {
					centroid = [(unit1.pos[0] + unit2.pos[0]) / 2, (unit1.pos[1] + unit2.pos[1]) / 2];
					offset = MainScene.vecTo(unit1.pos, unit2.pos);
					MainScene.normalize(offset, UNIT_RADIUS);
					unit1.pos = MainScene.diff(centroid, offset);
					unit2.pos = MainScene.sum(centroid, offset);
				}
			}
		}

		// Check for stuck units and stop them.
		for (unit : this.units) {
			if (unit.targetPos != null) {
				if (MainScene.d2(unit.pos, unit.lastPos) < (PROGRESS_THRESHOLD * UNIT_SPEED) ** 2.0) {
					unit.targetPos = null;
				}
			}
		}

		// The camera follows the necromage.
		this.cameraPos = [Math.floor(this.necromage.pos[0]), Math.floor(this.necromage.pos[1])];
	}

	function render() {
		Graphics2D.Draw.fill(43, 50, 57);

		bg = Images.get("bg.png");
		for (i = -1; i < X_RES / bg.width + 2; ++i) {
			for (j = -1; j < Y_RES / bg.height + 2; ++j) {
				bg.draw(i * bg.width - this.cameraPos[0] % bg.width, j * bg.height - this.cameraPos[1] % bg.height);
			}
		}

		p1 = this.gameToScreen([0, 100]);
		p2 = this.gameToScreen([0, -100]);
		p3 = this.gameToScreen([100, 0]);
		p4 = this.gameToScreen([-100, 0]);
		Graphics2D.Draw.line(p1[0], p1[1], p2[0], p2[1], 1, 255, 255, 255);
		Graphics2D.Draw.line(p3[0], p3[1], p4[0], p4[1], 1, 255, 255, 255);

		for (unit : this.units) {
			pos = this.gameToScreen(unit.pos);
			color = unit.targetPos == null
				? unit.color
				: [(unit.color[0] + 255) / 2, (unit.color[1] + 255) / 2, (unit.color[2] + 255) / 2]
				;
			Graphics2D.Draw.ellipse
				( Math.floor(pos[0]) - UNIT_RADIUS, Math.floor(pos[1]) - UNIT_RADIUS
				, 2 * UNIT_RADIUS, 2 * UNIT_RADIUS
				, color[0], color[1], color[2]
				);
		}
	}
}
