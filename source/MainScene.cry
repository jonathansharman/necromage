import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha4;

const X_RES = 800;
const Y_RES = 600;
const FPS = 60.0;
const ELAPSED_TIME = 1.0 / FPS;

const H_SCROLL = 200;
const V_SCROLL = 200;
const SCROLL_MULTIPLIER = 0.1;

const UNIT_RADIUS = 10.0;
const UNIT_SPEED = 80;
const UNIT_ATTACK_SPEED = 1.0;
const UNIT_ATTACK_DAMAGE = 10.0;

const PROGRESS_THRESHOLD = 0.25;

const CELL_SIZE = 30.0;

enum Faction { ALLY, ENEMY, NEUTRAL }

class Unit {
	field pos;
	field angle = Random.randomFloat() * 2 * Math.PI;
	field health = 100.0;
	field cooldown = 0.0;
	field faction;

	field targetPos;
	field lastPos;
	field color;

	constructor(pos, faction) {
		this.pos = pos;
		this.faction = faction;
	}

	function tryAttack(unit) {
		// Neutral units don't get involved in fights.
		if (this.faction == Faction.NEUTRAL || unit.faction == Faction.NEUTRAL) return;
		// Units from the same faction don't fight.
		if (this.faction == unit.faction) return;
		// Can't attack while on cooldown.
		if (this.cooldown > 0.0) return;

		this.cooldown = 1.0 / UNIT_ATTACK_SPEED;
		unit.health -= UNIT_ATTACK_DAMAGE;
	}
}

class Necromage : Unit {
	field zombies = [];

	constructor(pos) : base(pos, Faction.ALLY) {
		this.color = [0, 192, 255];
	}
}

class Zombie : Unit {
	constructor(pos) : base(pos, Faction.ALLY) {
		this.color = [64, 128, 0];
	}
}

class Peasant : Unit {
	constructor(pos) : base(pos, Faction.ENEMY) {
		this.color = [128, 96, 64];
	}
}

class Corpse : Unit {
	constructor(pos) : base(pos, Faction.NEUTRAL) {
		this.color = [128, 128, 128];
	}
}

class MainScene : AbstractScene {
	field cameraPos;
	field mouseDown = false;

	field units = [];
	field necromage;

	constructor() {
		this.necromage = new Necromage([0, 0]);
		this.cameraPos = this.necromage.pos.clone();
		this.units.add(this.necromage);

		for (i = 0; i < 50; ++i) {
			zombie = new Zombie([100, 0]);
			this.units.add(zombie);
			this.necromage.zombies.add(zombie);
		}
		for (i = 0; i < 50; ++i) {
			this.units.add(new Peasant([-100, 0]));
		}
	}

	function screenToGame(pos) {
		return
			[ pos[0] + this.cameraPos[0] - X_RES / 2
			, pos[1] + this.cameraPos[1] - Y_RES / 2
			];
	}
	function gameToScreen(pos) {
		return
			[ pos[0] - this.cameraPos[0] + X_RES / 2
			, pos[1] - this.cameraPos[1] + Y_RES / 2
			];
	}

	static function d(pos1, pos2) {
		return ((pos1[0] - pos2[0]) ** 2 + (pos1[1] - pos2[1]) ** 2) ** 0.5;
	}
	static function d2(pos1, pos2) {
		return (pos1[0] - pos2[0]) ** 2 + (pos1[1] - pos2[1]) ** 2;
	}
	static function len(pos) {
		return (pos[0] ** 2 + pos[1] ** 2) ** 0.5;
	}
	static function len2(pos) {
		return pos[0] ** 2 + pos[1] ** 2;
	}
	static function vecTo(pos, target) {
		return [target[0] - pos[0], target[1] - pos[1]];
	}
	static function add(pos, vec) {
		pos[0] += vec[0];
		pos[1] += vec[1];
	}
	static function sub(pos, vec) {
		pos[0] -= vec[0];
		pos[1] -= vec[1];
	}
	static function sum(pos, vec) {
		return [pos[0] + vec[0], pos[1] + vec[1]];
	}
	static function diff(pos, vec) {
		return [pos[0] - vec[0], pos[1] - vec[1]];
	}
	static function normalize(vec, newLen = 1.0) {
		len = MainScene.len(vec);
		vec[0] *= newLen / len;
		vec[1] *= newLen / len;
	}

	function update(inputManager, events) {
		mousePos = inputManager.getMousePosition();

		// Necromage movement.
		if (this.necromage.health > 0.0) {
			vel = [0.0, 0.0];
			if (inputManager.isKeyPressed(KeyboardKey.W)) {
				vel[1] -= 1.0;
			}
			if (inputManager.isKeyPressed(KeyboardKey.S)) {
				vel[1] += 1.0;
			}
			if (inputManager.isKeyPressed(KeyboardKey.A)) {
				vel[0] -= 1.0;
			}
			if (inputManager.isKeyPressed(KeyboardKey.D)) {
				vel[0] += 1.0;
			}
			if (vel[0] != 0.0 || vel[1] != 0.0) {
				MainScene.normalize(vel, UNIT_SPEED * ELAPSED_TIME);
			}
			MainScene.add(this.necromage.pos, vel);
		}

		for (e : events) {
			switch (e.type) {
				case EventType.MOUSE_PRESS:
					// Swarm command.
					targetPos = this.screenToGame(mousePos);
					for (zombie : this.necromage.zombies) {
						zombie.targetPos = targetPos.clone();
					}	
					break;
				default:
					break;
			}
		}

		// Update units.
		for (unit : this.units) {
			unit.cooldown -= ELAPSED_TIME;
			if (unit.targetPos != null) {
				unit.lastPos = unit.pos.clone();
				d2 = MainScene.d2(unit.pos, unit.targetPos);
				if (d2 < (UNIT_SPEED * ELAPSED_TIME) ** 2) {
					unit.pos = unit.targetPos;
					unit.targetPos = null;
				} else {
					vec = MainScene.vecTo(unit.pos, unit.targetPos);
					MainScene.normalize(vec, UNIT_SPEED * ELAPSED_TIME);
					MainScene.add(unit.pos, vec);
				}
			}
		}

		// Collisions.
		for (i = 0; i < this.units.length - 1; ++i) {
			unit1 = this.units[i];
			for (j = i + 1; j < this.units.length; ++j) {
				unit2 = this.units[j];
				d2 = MainScene.d2(unit1.pos, unit2.pos);
				if (d2 == 0.0) {
					// Separate in a random direction if completely overlapping.
					theta = Random.randomFloat() * 2 * Math.PI;
					offset = [Math.cos(theta) * UNIT_RADIUS, Math.sin(theta) * UNIT_RADIUS];
					MainScene.add(unit1.pos, offset);
					MainScene.sub(unit2.pos, offset);
				} else if (d2 < (2.0 * UNIT_RADIUS) ** 2) {
					// Separate.
					centroid = [(unit1.pos[0] + unit2.pos[0]) / 2, (unit1.pos[1] + unit2.pos[1]) / 2];
					offset = MainScene.vecTo(unit1.pos, unit2.pos);
					MainScene.normalize(offset, UNIT_RADIUS);
					unit1.pos = MainScene.diff(centroid, offset);
					unit2.pos = MainScene.sum(centroid, offset);
					// Try to attack each other.
					unit1.tryAttack(unit2);
					unit2.tryAttack(unit1);
				}
			}
		}

		// Check for dead units.
		for (i = 0; i < this.units.length; ++i) {
			unit = this.units[i];
			if (unit.health <= 0.0) {
				this.units[i] = new Corpse(unit.pos);
			}
		}

		// Check for stuck units and stop them.
		for (unit : this.units) {
			if (unit.targetPos != null) {
				if (MainScene.d2(unit.pos, unit.lastPos) < (PROGRESS_THRESHOLD * UNIT_SPEED * ELAPSED_TIME) ** 2) {
					unit.targetPos = null;
				}
			}
		}

		// Camera movement.
		this.cameraPos =
			[ Math.floor(this.necromage.pos[0] + mousePos[0] - X_RES / 2)
			, Math.floor(this.necromage.pos[1] + mousePos[1] - Y_RES / 2)
			];
	}

	function render() {
		Graphics2D.Draw.fill(43, 50, 57);

		bg = Images.get("bg.png");
		for (i = -1; i < X_RES / bg.width + 2; ++i) {
			for (j = -1; j < Y_RES / bg.height + 2; ++j) {
				bg.draw(i * bg.width - this.cameraPos[0] % bg.width, j * bg.height - this.cameraPos[1] % bg.height);
			}
		}

		for (unit : this.units) {
			pos = this.gameToScreen(unit.pos);
			color = unit.targetPos == null
				? unit.color
				: [(unit.color[0] + 255) / 2, (unit.color[1] + 255) / 2, (unit.color[2] + 255) / 2]
				;
			Graphics2D.Draw.ellipse
				( Math.floor(pos[0]) - UNIT_RADIUS, Math.floor(pos[1]) - UNIT_RADIUS
				, 2 * UNIT_RADIUS, 2 * UNIT_RADIUS
				, color[0], color[1], color[2]
				);
		}
	}
}
